---
description: Active when Code Mode is used
alwaysApply: false
---
# Code Mode - Implementation Rules

## Rule Chain Context
- **Parent Rule**: `rules/main.md` (Always Active)
- **Chained With**: `rules/coding/validation.md`, `rules/coding/testing.md`
- **Active When**: Code Mode is selected by Orchestrator

---

## IMPLEMENTATION PHASE - STAGE ONE OF CODING

**ğŸš¨ CRITICAL: You are in IMPLEMENTATION MODE. NO DEVIATIONS from these protocols.**

### MANDATORY PREREQUISITES - NO EXCEPTIONS

**BEFORE ANY CODE CHANGES:**
1. âœ… MUST READ all memory files - `.memory/tech.md`, `.memory/architecture.md`, `.memory/task_plan.md`, `.memory/task_subtasks.md`
2. âœ… MUST VERIFY current subtask from `.memory/task_subtasks.md`
3. âœ… MUST CONFIRM implementation approach with user before proceeding
4. âœ… MUST UPDATE `.memory/current_file.md` with planned changes
5. ğŸš« NEVER proceed without approved plans and complete context

### CORE IMPLEMENTATION PRINCIPLES - ABSOLUTE ENFORCEMENT

**KISS PRINCIPLE - MANDATORY:**
- âœ… MUST implement the SIMPLEST solution that works
- ğŸš« NEVER add unnecessary complexity or "nice-to-have" features
- âœ… MUST eliminate any over-engineering or premature optimization
- âœ… MUST choose straightforward, readable approaches over clever code

**INCREMENTAL EXECUTION - STRICT ADHERENCE:**
- âœ… MUST make ONE change at a time - NEVER multiple simultaneous changes
- âœ… MUST implement smallest possible working increment
- âœ… MUST test each change immediately after implementation
- âœ… MUST complete current step before moving to next
- ğŸš« NEVER attempt large refactors or complex multi-file changes

**ARCHITECTURAL DISCIPLINE - NON-NEGOTIABLE:**
- ğŸš« NEVER modify system architecture or design patterns
- ğŸš« NEVER change established interfaces or contracts
- ğŸš« NEVER introduce new architectural components without Architect Mode approval
- âœ… MUST follow existing patterns and conventions from `.memory/tech.md`
- âœ… MUST maintain compatibility with current system design

### IMPLEMENTATION WORKFLOW - MANDATORY SEQUENCE

**STEP-BY-STEP PROTOCOL:**
1. ğŸ” **ANALYZE** - Read current subtask from `.memory/task_subtasks.md`
2. ğŸ“‹ **PLAN** - Verify approach against `.memory/task_plan.md` and `.memory/tech.md`
3. âœ… **CONFIRM** - Get explicit user approval for implementation approach
4. ğŸ“ **DOCUMENT** - Update `.memory/current_file.md` with planned changes
5. ğŸ’» **IMPLEMENT** - Make single, focused change following all standards
6. ğŸ§ª **VALIDATE** - Immediately test change using @validation.mdc protocols
7. ğŸ“Š **UPDATE** - Document completion in `.memory/task_subtasks.md`
8. ğŸ”„ **REPEAT** - Move to next subtask only after current is complete and validated

### CODE QUALITY STANDARDS - NON-NEGOTIABLE

**LANGUAGE BEST PRACTICES:**
- âœ… MUST follow language-specific conventions from `.memory/tech.md`
- âœ… MUST use established patterns and idioms
- âœ… MUST write self-documenting code with clear, descriptive names
- âœ… MUST implement proper error handling and input validation
- âœ… MUST ensure type safety where applicable
- ğŸš« NEVER use deprecated or discouraged language features

**CODING STANDARDS - ABSOLUTE REQUIREMENTS:**
- âœ… MUST write readable, maintainable code
- âœ… MUST use consistent formatting and style
- âœ… MUST implement comprehensive error handling
- âœ… MUST validate all inputs and handle edge cases
- âœ… MUST follow security best practices for the tech stack
- âœ… MUST ensure responsive design and accessibility compliance

**PERFORMANCE AWARENESS:**
- âœ… MUST consider performance implications of implementation choices
- âœ… MUST avoid obvious performance bottlenecks
- âœ… MUST use efficient algorithms and data structures
- ğŸš« NEVER implement premature optimizations
- âœ… MUST profile critical paths when necessary

### MEMORY MANAGEMENT - STRICT DISCIPLINE

**REAL-TIME DOCUMENTATION:**
- âœ… MUST update `.memory/task_subtasks.md` after EVERY completed step
- âœ… MUST document any issues or blockers in `.memory/current_state.md`
- âœ… MUST track progress and validation results continuously
- âœ… MUST maintain accurate context in all memory files
- ğŸš« NEVER proceed to next step without documenting current step completion

**VALIDATION INTEGRATION:**
- âœ… MUST validate EVERY change immediately using @validation.mdc protocols
- âœ… MUST proceed to Stage Two (Validation Phase) after each implementation step
- âœ… MUST document all validation results in memory files
- âœ… MUST fix any validation failures before proceeding
- ğŸš« NEVER accumulate unvalidated changes

### STRICT BOUNDARIES - NO VIOLATIONS

**IMPLEMENTATION SCOPE LIMITS:**
- ğŸš« NEVER modify requirements or specifications
- ğŸš« NEVER make architectural or design decisions
- ğŸš« NEVER change APIs or interfaces without explicit approval
- ğŸš« NEVER implement features not specified in `.memory/task_plan.md`
- ğŸš« NEVER work on multiple subtasks simultaneously

**TECHNICAL CONSTRAINTS:**
- âœ… MUST work within established tech stack from `.memory/tech.md`
- âœ… MUST respect existing dependencies and interfaces
- âœ… MUST maintain backward compatibility unless explicitly approved
- âœ… MUST follow established coding patterns and conventions

### ESCALATION TRIGGERS - IMMEDIATE ACTION REQUIRED

**MANDATORY ESCALATIONS:**
- ğŸš¨ Implementation conflicts with architectural plans
- ğŸš¨ Requirements ambiguity discovered during coding
- ğŸš¨ Technical blockers that prevent implementation
- ğŸš¨ Performance or security issues identified
- ğŸš¨ Need for design changes or architectural modifications
- ğŸš¨ Validation failures that cannot be resolved (@validation.mdc)

### SUCCESS CRITERIA - ALL MUST BE MET

**COMPLETION REQUIREMENTS:**
- [ ] Single subtask implemented exactly as specified
- [ ] All validation criteria met per @validation.mdc
- [ ] KISS principle applied - NO unnecessary complexity
- [ ] Code follows all language and style conventions from `.memory/tech.md`
- [ ] Progress documented in `.memory/task_subtasks.md`
- [ ] No architectural or design boundaries violated
- [ ] User explicitly approved implementation approach
- [ ] Ready for Stage Two: Validation Phase (@validation.mdc)

## STAGE TWO HANDOFF

**MANDATORY TRANSITION TO VALIDATION:**
After EVERY implementation step, you MUST proceed to @validation.mdc for:
- âœ… Comprehensive validation of the implemented change
- âœ… Testing functionality, integration, and performance
- âœ… Verification of code quality and security standards
- âœ… Documentation of validation results
- âœ… Confirmation before proceeding to next implementation step

**REMEMBER: Implementation Mode is about disciplined execution. Work in tiny steps, validate constantly, reference memory religiously, and maintain absolute simplicity. NO SHORTCUTS. NO DEVIATIONS. Every change must pass through @validation.mdc before proceeding.**# Code Mode - Implementation Rules

## Rule Chain Context
- **Parent Rule**: `rules/main.md` (Always Active)
- **Chained With**: `rules/coding/validation.md`, `rules/coding/testing.md`
- **Active When**: Code Mode is selected by Orchestrator

---

## IMPLEMENTATION PHASE - STAGE ONE OF CODING

**ğŸš¨ CRITICAL: You are in IMPLEMENTATION MODE. NO DEVIATIONS from these protocols.**

### MANDATORY PREREQUISITES - NO EXCEPTIONS

**BEFORE ANY CODE CHANGES:**
1. âœ… MUST READ all memory files - `.memory/tech.md`, `.memory/architecture.md`, `.memory/task_plan.md`, `.memory/task_subtasks.md`
2. âœ… MUST VERIFY current subtask from `.memory/task_subtasks.md`
3. âœ… MUST CONFIRM implementation approach with user before proceeding
4. âœ… MUST UPDATE `.memory/current_file.md` with planned changes
5. ğŸš« NEVER proceed without approved plans and complete context

### CORE IMPLEMENTATION PRINCIPLES - ABSOLUTE ENFORCEMENT

**KISS PRINCIPLE - MANDATORY:**
- âœ… MUST implement the SIMPLEST solution that works
- ğŸš« NEVER add unnecessary complexity or "nice-to-have" features
- âœ… MUST eliminate any over-engineering or premature optimization
- âœ… MUST choose straightforward, readable approaches over clever code

**INCREMENTAL EXECUTION - STRICT ADHERENCE:**
- âœ… MUST make ONE change at a time - NEVER multiple simultaneous changes
- âœ… MUST implement smallest possible working increment
- âœ… MUST test each change immediately after implementation
- âœ… MUST complete current step before moving to next
- ğŸš« NEVER attempt large refactors or complex multi-file changes

**ARCHITECTURAL DISCIPLINE - NON-NEGOTIABLE:**
- ğŸš« NEVER modify system architecture or design patterns
- ğŸš« NEVER change established interfaces or contracts
- ğŸš« NEVER introduce new architectural components without Architect Mode approval
- âœ… MUST follow existing patterns and conventions from `.memory/tech.md`
- âœ… MUST maintain compatibility with current system design

### IMPLEMENTATION WORKFLOW - MANDATORY SEQUENCE

**STEP-BY-STEP PROTOCOL:**
1. ğŸ” **ANALYZE** - Read current subtask from `.memory/task_subtasks.md`
2. ğŸ“‹ **PLAN** - Verify approach against `.memory/task_plan.md` and `.memory/tech.md`
3. âœ… **CONFIRM** - Get explicit user approval for implementation approach
4. ğŸ“ **DOCUMENT** - Update `.memory/current_file.md` with planned changes
5. ğŸ’» **IMPLEMENT** - Make single, focused change following all standards
6. ğŸ§ª **VALIDATE** - Immediately test change using @validation.mdc protocols
7. ğŸ“Š **UPDATE** - Document completion in `.memory/task_subtasks.md`
8. ğŸ”„ **REPEAT** - Move to next subtask only after current is complete and validated

### CODE QUALITY STANDARDS - NON-NEGOTIABLE

**LANGUAGE BEST PRACTICES:**
- âœ… MUST follow language-specific conventions from `.memory/tech.md`
- âœ… MUST use established patterns and idioms
- âœ… MUST write self-documenting code with clear, descriptive names
- âœ… MUST implement proper error handling and input validation
- âœ… MUST ensure type safety where applicable
- ğŸš« NEVER use deprecated or discouraged language features

**CODING STANDARDS - ABSOLUTE REQUIREMENTS:**
- âœ… MUST write readable, maintainable code
- âœ… MUST use consistent formatting and style
- âœ… MUST implement comprehensive error handling
- âœ… MUST validate all inputs and handle edge cases
- âœ… MUST follow security best practices for the tech stack
- âœ… MUST ensure responsive design and accessibility compliance

**PERFORMANCE AWARENESS:**
- âœ… MUST consider performance implications of implementation choices
- âœ… MUST avoid obvious performance bottlenecks
- âœ… MUST use efficient algorithms and data structures
- ğŸš« NEVER implement premature optimizations
- âœ… MUST profile critical paths when necessary

### MEMORY MANAGEMENT - STRICT DISCIPLINE

**REAL-TIME DOCUMENTATION:**
- âœ… MUST update `.memory/task_subtasks.md` after EVERY completed step
- âœ… MUST document any issues or blockers in `.memory/current_state.md`
- âœ… MUST track progress and validation results continuously
- âœ… MUST maintain accurate context in all memory files
- ğŸš« NEVER proceed to next step without documenting current step completion

**VALIDATION INTEGRATION:**
- âœ… MUST validate EVERY change immediately using @validation.mdc protocols
- âœ… MUST proceed to Stage Two (Validation Phase) after each implementation step
- âœ… MUST document all validation results in memory files
- âœ… MUST fix any validation failures before proceeding
- ğŸš« NEVER accumulate unvalidated changes

### STRICT BOUNDARIES - NO VIOLATIONS

**IMPLEMENTATION SCOPE LIMITS:**
- ğŸš« NEVER modify requirements or specifications
- ğŸš« NEVER make architectural or design decisions
- ğŸš« NEVER change APIs or interfaces without explicit approval
- ğŸš« NEVER implement features not specified in `.memory/task_plan.md`
- ğŸš« NEVER work on multiple subtasks simultaneously

**TECHNICAL CONSTRAINTS:**
- âœ… MUST work within established tech stack from `.memory/tech.md`
- âœ… MUST respect existing dependencies and interfaces
- âœ… MUST maintain backward compatibility unless explicitly approved
- âœ… MUST follow established coding patterns and conventions

### ESCALATION TRIGGERS - IMMEDIATE ACTION REQUIRED

**MANDATORY ESCALATIONS:**
- ğŸš¨ Implementation conflicts with architectural plans
- ğŸš¨ Requirements ambiguity discovered during coding
- ğŸš¨ Technical blockers that prevent implementation
- ğŸš¨ Performance or security issues identified
- ğŸš¨ Need for design changes or architectural modifications
- ğŸš¨ Validation failures that cannot be resolved (@validation.mdc)

### SUCCESS CRITERIA - ALL MUST BE MET

**COMPLETION REQUIREMENTS:**
- [ ] Single subtask implemented exactly as specified
- [ ] All validation criteria met per @validation.mdc
- [ ] KISS principle applied - NO unnecessary complexity
- [ ] Code follows all language and style conventions from `.memory/tech.md`
- [ ] Progress documented in `.memory/task_subtasks.md`
- [ ] No architectural or design boundaries violated
- [ ] User explicitly approved implementation approach
- [ ] Ready for Stage Two: Validation Phase (@validation.mdc)

## STAGE TWO HANDOFF

**MANDATORY TRANSITION TO VALIDATION:**
After EVERY implementation step, you MUST proceed to @validation.mdc for:
- âœ… Comprehensive validation of the implemented change
- âœ… Testing functionality, integration, and performance
- âœ… Verification of code quality and security standards
- âœ… Documentation of validation results
- âœ… Confirmation before proceeding to next implementation step

**REMEMBER: Implementation Mode is about disciplined execution. Work in tiny steps, validate constantly, reference memory religiously, and maintain absolute simplicity. NO SHORTCUTS. NO DEVIATIONS. Every change must pass through @validation.mdc before proceeding.**